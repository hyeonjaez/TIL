## 1. 캡슐화의 필요성

### 🧠 개념 설명
- 캡슐화는 객체 내부의 필드값이나 내부 구현을 외부로부터 직접적인 접근을 차단하고 감추는 것이다.


**왜? 필요할까?**
```java
public class MyMoney {
  private int money;

  public int getMoney() {
    return this.money;
  }

  public void depositMoney(int depositAmount){
    if(depositAmount <= 0) {
      throw new IllegalArgumentException("0 이상의 값이어야 한다.");
    }
    this.money += depositAmount;
      return;
  }

  public void withdrawalMoney(int withdrawalAmount){
    if(withdrawalAmount <= 0 || withdrawalAmount > this.money) {
      throw new IllegalArgumentException("0 이상의 값이거나 현재 내 돈보다 작거나 같아야한다.");
    }

    this.money -= withdrawalAmount;
  }
}
```

위의 코드처럼 money라는 필드값이 있다. 이 클래스의 이 필드값의 규칙은 뭘까? 
1. 0 이상의 값이어야 한다.
2. money 의 필드값의 변경은 depositMoney(), withdrawalMoney()를 통해서만 변경하고 있다.

메서드도 보면 각각 다음과 같은 precondition이 있어야한다.
depositMoney() 메서드의 precondtion 
- 1. 파라미터 값이 0 이상의 값이어야 한다.

withdrawalMoney() 메서드의 precondition
- 1. 파라미터 값이 0 이상의 값이어야 한다.
  2. 현재 나의 돈보다 작거나 같아야 한다.
 
<br/>


위와 같이 MyMoney라는 Class 의 내부 규칙이다.

하지만 만약 private int money; 의 접근 제어자를 public으로 하면 어떻게 될까?
-> 해당 클래스의 규칙에 어긋나게 된다.
-> 잘못된 값이 들어올수 있다.

이제 그리고 해당 두 메서드들을 외부에서 구현한뒤 이 money 값을 쓴다고 하자
그럼 MyMoney의 Class 규칙이 바뀌면 어떻게 될까? 그러면 외부에서 이 메서드들과 묶여 있는 어떠한 것들도 다 바꿔야한다.



<br/>

**위의 예시와 같이 캡슐화의 이유를 정의하자면**


1. 데이터 보호
  - 객체의 내부 데이터를 외부에서 변경하지 못하도록 한다.
2. 유지보수성
  - 내부 구현을 감추면 구현 방식이 바뀌어도 외부 코드에 영향을 주지 않아 변경이 쉽다.
3. 일관성 유지
  - 직접 필드를 노출하지 않고 해당 class의 규칙대로 필드를 접근하게 한다고 하면 잘못된 값이 들어올 위험을 차단한다.


---
### ✅ 한줄로 설명 하기

- 캡슐화는 객체의 데이터를 직접 접근하지 못하게 막고 반드시 검증된 방식으로만 접근하도록하여 데이터 보호와 유지보수성을 높이기 위해 사용한다.
