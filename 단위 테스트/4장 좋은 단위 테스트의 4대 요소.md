## 4장 좋은 단위 테스트의 4대 요소


**좋은 단위 테스트의 4가지 특성**
- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

<br/>

**1 - 회귀 방지**
- 코드를 수정한 후 기느이 의도한 대로 작동하지 않는 경우
- 코드 변경 후 발생할 수 있는 버그를 조기에 발견해야 한다
- 높은 회귀 방지 능력을 가진 테스트는 깨질 때 가치가 있는 테스트이다

- 특징 :
  - 실제 사용자 시나리오와 밀접
  - 도메인 동작을 테스트
  - 잘못된 동작이 생기면 반드시 실패한다
 
- 나쁜 테스트 :
  - 구현 세부사항만 검증
  - 경로만 커버하고 의미 있는 검증이 없음
 
<br/>

**2 - 리팩터링 내성**
- 좋은 테스트는 내부 구현 변경에 취약하지 않아야 한다
- 테스트는 행동에 집중하고 구현에는 의존하지 않아야 한다
- 구현에 민감한 테스트는 개발자의 리팩터링 의지를 꺾는다
- ex)
  - 내부 메서드 호출 횟수나 특정 필드 접근을 검증하는 테스트 X
  - 외부에서 보이는 결과값이나 상태 변환만 검증하는 테스트
 
<br/>

**3 - 빠른 실행 속도**
- 단위 테스트는 개발자의 피드백 루프를 짧게 만들어야 한다
- 실행이 느려질수록 테스트를 자주 돌리지 않게 되고 신뢰도가 떨어진다
- 느린 테스트는 보통 통합 테스트 수준의 책임을 갖고 있는 경우가 많다
- 좋은 테스트:
  - DB, 파일 시스템, 네트워크 등 외부 I/O 의존하지 않는 것
  - 메모리 내에서 빠르게 실행
  - 초 단위 이하의 응답 시간

<br/>

**4 - 유지보수성**
- 시간이 지날수록 테스트는 점점 쌓이기 때문에 읽기 쉽고 수정하지 쉬운 테스트가 중요하다
- 유지보수가 어려운 테스트는 회귀 방지 능력이 높더라도 점점 방치될 가능성이 높다

- 특징 :
  - 테스트 이름이 명확하고 의도가 드러남
  - 픽스처가 단순하고 중복이 없음
  - 실행 구절이 짧고 불필요한 검증이 없다
  - 테스트 실패 시 원인을 빠르게 파악할 수 있다

<br/>

**이상적인 테스트를 찾아서**
- 모든 테스트가 4대 요소를 완벽히 만족할 수 없지만 어떤 테스트는 더 이상적일 수 있다
- 현실적으로 테스트는 네 요소 사이에서 트레이드오프가 필요하다

**이상적인 테스트를 만들수 있는가?**
- 이상적인 테스트를 항상 만들 수 없다 하지만 그에 가까운 테스트를 설계하는 것이 목표다
- 테스트의 특성과 목적에 따라 어떤 요소에 더 무게를 둘지 전략적으로 선택해야 한다
- ex)
  - 핵심 도메인 로직 -> 회귀 방지 능력 + 리팩터링 내성 중점
  - 경계나 유틸리티 로직 -> 속도 + 유지보수성 중점
  - 인프라 의존 테스트 -> 회귀 방지 능력은 높지만 속도나 내성이 낮을 수 있다
 
<br>

**대중적인 테스트 자동화 개념**
- 테스트 자동화의 개념 중 일부는 실제로 좋은 테스트를 만드는 데 도움이 되지만
- 일부는 오히려 테스트의 품질을 떨어뜨릴 수 있다

**1 - 테스트 피라미드**
- 단위 테스트 -> 통합 테스트 -> E2E 테스트 구조를 피라미드 형태로 표현
- 아래로 갈수록 속도가 빠르고 위로 갈수록 속도는 느리지만 커버리지가 넓다

- 장점 : 테스트 범위를 계층적으로 나누어 효율적으로 관리할 수 있다
- 주의점 :
  - 피라미드 모양 자체가 목적이 되어선 안된다
  - 단위 테스트 비중이 높다고 해서 테스트 품질이 자동으로 좋아지지 않는다
 
<br/>

**2 - 테스트 아이스 크림 콘**
- 피라미드와 반대로 단위 테스트는 적고 E2E 테스트가 많은 비정상적 구조를 뜻함
- 실제로 많은 조직에서 테스트가 이렇게 되어 있는 경우가 많다
- 자동화 테스트는 느리고 불안정하며 유지보수가 어려워 진다
- 단점 :
  - E2E 테스트만으로는 빠르고 안정적인 피드백 루프를 만들기 어렵다
  - 실패 원인 추적도 어렵고 리팩터링에 매우 취약하다
 
<br/>

**3 - 테스트 다이아몬드**
- 단위 테스트와 E2E 테스트를 줄이고 중간 레벨 (서비스/통합 테스트)의 비중을 늘리는 전략
- 현실적인 타협 모델로 평가 받는다
- 장점 :
  - E2E 테스트의 부담을 줄이고 핵심 통합 로직에 집중 가능
  - 속도와 회귀 방지 능력의 균형을 잡을 수 있다
- 단점 :
  - 통합 테스트가 리팩터링에 취약할 수 있어서 설계가 중요하다

<br/>

**블랙박스 테스트와 화이트 박스 테스트 간의 선택**
- 블랙박스 테스트 :
  - 외부에서 보이는 동작
  - 검증 대상 : API, 반환값, 외부 상태 변화
  - 리팩터링 영향 : 적음
 
- 화이트 박스 테스트 :
  - 내부 구현
  - 검증 대상 : 메서드 호출, 내부 필드, 알고리즘 로직
  - 리팩터링 영향 :큼
 
- 좋은 단위 테스트는 가능하면 블랙박스 테스트 방식을 택해야한다
- 화이트 박스 테스트는 구현 세부사항에 결합되기 때문에 리팩터링 내성이 약하다
- 블랙박스 테스트는 행동기반으로 작성되기 때문에 내부 설계가 바뀌어도 테스트가 그대로 유지될 가능성이 높다
- 하지만 화이트 박스 테스트는 내부 구조(메서드 호출 순서, 특정 객체 사용)에 의존해서 구현 변경에 매우 취약하다


<br/>

**블랙박스 테스트를 우선하라는 이유**
- 내부 구현은 시간이 지남에 따라 가장 많이 바뀌는 부분이다
- 테스트가 구현에 강하게 결합되어 있으면 리팩터링이 테스트의 발목을 잡는 상황이 발생한다
- 테스트는 개발자를 묶는 족쇄가 아니라 안정망이어야 한다

- 그래서:
  - 가능한 한 테스트 블랙박스 관점에서 설계할 것
  - 내부 구현 검증이 필요한 경우는 최소화할 것
  - Mocking, verify 호출 등은 님용하지 말 것

<br/>

**예외 상황**
- 매우 복잡한 알고리즘이나 핵심 내부 로직에서 화이트 박스 테스트가 필요할 수 있다
- 하지만 이런 경우에도 구현의 세부사항이 아니라 계약에 집중하도록 작성해야 한다
