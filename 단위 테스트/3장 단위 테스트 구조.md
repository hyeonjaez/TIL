## 3장 단위 테스트 구조

**AAA 패턴**
- 각 테스트를 준비, 실행, 검증이라는 세 부분으로 나눌 수 있다.
- 장점 : 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다

- 구조 :
  - 준비 구절: 테스트 대상 시스템과 해당 의존성을 원하는 상태로 만든다
  - 실행 구절: SUT에서 메서드를 호출하고 준비된 의존성을 전ㄷ라하며 출력 값을 캡처한다
  - 검증 구절: 결과를 검증한다.

 <br/>
 
**Given-When-Then 패턴**
- AAA와 유사한 패턴이다.
- Given : 준비 구절
- When : 실행 구절
- Then : 검증 구절
- AAA 패턴과 차이는 없다.

<br/>

**테스트 내 if문 피하기**
- if 문이 있는 단위테스트들이 있을수도 있지만 안티 패턴이다
- 단위 테스트든 통합 테스트든 테스트는 분기가 없는 간단한 일련의 단계여야 한다
- if문이 있는 단위테스트를 해결하려면 여러 테스트로 나눠야 한다
- 왜냐하면 분기가 있으면 얻는 이점은 없다
- 단지 추가 유지비만 불어날 뿐이다

<br/>

**각 구절의 크기?**
1. 준비 구절이 가장 큰 경우:
  - 일반적으로는 준비 구절이 세 구절 중 가장 크다
  - 엄청 커지면 같은 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다
  - 준비 구절에서 코드 재사용에 도움이 되는 두가지 패턴으로는 Object Mother, Test Data Builder가 있다.

<br/>

2. 실행 구절이 한 줄 이상인 경우를 경계하자:
  - 실행 구절은 보통 코드 한줄이다
  - 실행 구절이 두 줄 이상인 경우에는 SUT의 공개 API에 문제가 있을 수 있다.
  - 이렇게 두 줄 이상인 경우에는 테스트의 문제가 아니라 프로덕션 코드의 설계 문제일 가능성이 높다
  - 이런 문제는 객체의 불변성과 캡슐화를 강화해야 한다
    - 불변?: 객체의 정상 상태를 보장하는 조건이다
    - 불변 위반이 Act 구절을 복잡하게 만든다
    - 캡슐화 위반? : 캡슐화는 객체의 내부 상태와 불변조건을 외부에서 보호하는 개념이다
  - 결과적으로 캡슐화와 불변을 잘 지키는 설계는 테스트도 단순하게 만든다

<br/>    

3. 검증 구절에는 검증문이 얼마나 있어야할까?
  - 단위 테스트의 단위는 동작의 단위이다
  - 단일 동작 단위는 여러 결과를 낼 수 있고 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다
  - 하지만 검증 구절이 너무 커지는 것은 경계해야 한다:
    - 제품 코드에서 추상화가 누락됐을 수 있다
    - SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의하는 것이 좋다


<br/>

**준비, 실행, 검증 주석 제거하기**
- 각 구절을 시작하기 전에 주석을 다는것은 테스트 내에서 각 구절을 파악하는데에 좋다
- 하지만 AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하자
- 그렇지 않으면 주석을 유지

<br/>

**테스트 프레임워크는 단위 테스트의 3단계 구조를 자연스럽게 강제하는 환경이다**
- xUnit 이란? : 다양한 언어에서 단위 테스트를 작성할 수 있게 도와주는 공통 테스트 프레임워크 패턴이다.
- Java : JUnit
- 구성요소:
  - 테스트 메서드
  - 테스트 픽스처
  - 테스트 실행
  - 어서션
  - 테스트 러너

<br/>

**테스트 픽스처의 역할**
- 픽스터는 테스트 실행 전에 필요한 공통 준비 단계를 담는다
- DB연결, 객체 생성, Mock 설정 등
- 단점 2가지:
  - 테스트 간 결합도가 높아짐
  - 테스트 가독성이 떨어짐 

<br/>

**테스트 간의 높은 결합도는 안티 패턴이다**
- 좋은 테스트는 독립적이어야 한다 테스트 간 결합도는 테스트 코드의 품질을 빠르게 악화시킨다
- 테스트가 서로 공유 자원이나 공통 상태에 의존하게 되면, 하나의 테스트 실패가 다른 테스트 결과에도 영향을 줄 수 있다
- 테스트가 결합되어 있으면 원인 추적이 어렵고 테스트의 신뢰성이 떨어진다
- 특히 픽스처를 잘못 재사용할 경우, 한 테스트의 실행 결과가 다음 테스트의 입력이 되는 식으로 연결되는 문제가 자주 발생한다

<br/>

**테스트 가독성을 떨어뜨리는 생성자 사용**
- 테스트에서 복잡한 객체 생성은 가독성을 해치고 테스트의 목적을 흐린다
- 프로덕션 코드의 복잡한 생성자를 그대로 테스트에서 사용하면 테스트 코드가 장황해진다
- 개선 방법으로는 테스트 헬퍼나 빌더를 사용하자

<br/>

**더 나은 테스트 픽스처 재사용법**
- 픽스처는 공유가 아니라 캡슐화를 통해 재사용해야 한다
- 공유 변수로 쓰는 건 결합도를 높이는 안티 패턴
- 하지만 픽스터 생성 자체를 반복하는 것도 비효율적이다
- 그래서 픽스처 생성 로직만 재사용하고 객체 인스턴스는 매 테스트마다 새로 만들자 

<br/>

**단위 테스트 명명법**
- 명명법은 테스트의 의도를 한눈에 드러내는 설계 행위이다
- 기준:
  - 명확성 : 테스트 목적을 한눈에 알 수 있어야 함
  - 행동 중심 : 내부 구현이 아니라 동작에 집중
  - 조건과 결과가 드러날 것 : 언제 무엇을 어떻게 조합
  - 일관성 : 팀 내 통일된 규칙 유지

<br/>

- 대표적인 명명 패턴
  - 1. Should + 기대 결과 + when + 조건
    2. MethodName_Scenario_ExpectedResult
    3. Given_When_Then 패턴
   
<br/>

- 이름을 잘 지으면 얻는 이점
  - 테스트를 설계 문서처럼 읽을 수 있음
  - 코드 리뷰 시 의도 파악이 쉬움
  - 실패 했을 때 어떤 조건에서 어떤 결과가 깨졌는지 바로 알 수 있음
  - 리팩터링 후에도 테스트 유지 보수가 쉬워짐 

<br/>

**매개변수화된 테스트 리팩터링하기**
- 단위 테스트를 짧고 읽기 쉬운 상태로 유지하기 위해서는 중복을 제거하되 테스트 의도를 흐리지 말자

1. 반복되는 테스트는 안티 패턴
  - 테스트 대상 로직은 같고 입력값과 기대값만 다를때
  - 테스트가 많아 질수록 중복된 Arrange / Act/ Assert 코드가 늘어난다
  - 유지보수 비용 증가, 테스트 의도 파악이 어려워진다
  - 이럴 땐 매개변수화 테스트가 필요하다

<br/>

2. 매개변수화된 테스트?
  - 같은 테스트 로직을 여러 입력값에 대해 반복 실행할 수 있도록 일반화된 테스트
  - 장점:
    - 테스트 코드 중복 제거
    - 테스트 케이스 추가가 간단
    - 테스트 의도가 명확해짐
   
<br/>

3. 테스트 설계 개선 효과
  - 테스트 유지보수성 증가
  - 가독성 향상
  - 의도 명확

4. 주의할 점
  - 테스트 로직은 동일해야 함
  - 너무 많은 데이터는 피하자
  - 실패 시 원인 파악 용이성

