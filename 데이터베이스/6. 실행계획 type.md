## 실행 계획 type 
- 쿼리의 실행 계획에서 type 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다
- type 컬럼에 따라 쿼리의 성능과 튜닝 필요 영부를 판단할 수 있다


### type 칼럼의 종류
일단 아래와 같이 순서로 성능이 빠르다
1. system
2. const
3. eq_ref
4. ref
5. fulltext
6. ref_or_null
7. index_merge
8. unique_subquery
9. index_subquery
10. range
11. index (index Full Scan)
12. ALL (Full Table Scan)


<br/>





 **1. system**
- 레코드가 1건만 존재하는 테이블, 한건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다
- InnoDB에서는 X, MyISAM, MEMORY 테이블에서만 사용되는 접근 방법


**2. const**

- 테이블의 레코드 건수와 관계없이 PK, UK 칼럼을 이용하는 WHERE 조건절을 가지고 있다
- 무조건 1건을 반환하는 쿼리의 처리 방식이다
- 다른 DBMS에서는 유니크 인덱스 스캔이라고 표현한다

- 하지만 PK가 다중 칼럼으로 구성되어 있거나 UK 중에서 인덱스의 일부 칼럼만 조건으로 사용할때는 const 타입의 접근방법을 사용할 수 있다

ex) select * from employees where emp_no= 10001;

**3. eq_ref**
- 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨 
- join 에서 처음 읽은 테이블의 칼럼값이 그 다음 읽어야할 테이블의 PK or 유니크 칼럼의 검색 조건에 사용할때를 가리켜 eq_ref라고 한다 
- 결과가 반드시 1건일때이다
- 유니크 컬럼은 NOT NULL 이어야함

ex) select * from dept_emp de, employees e
where e.emp_no = de.emp_no and de.dept_no = d005;


**4. ref**
- eq_ref 와 다르게 join 순서와 관계없다
- PK, UK 제약조건도 없다
- 단건 조회 보장되지 않아도 됨 (유니크 제약이 없어서) 그래서 추가적인 scan을 거쳐서 const, eq_ref 보다 느림
- 인덱스 종류와 관계없이 동등 조건으로 검색할때


select * from dept_emp where dept_no = d005;




**5. fullext**
- 전문 검색 인덱스를 사용해서 레코드를 읽는 접근 방법
- 지금까지는 순서가 일반적인 순서이기 한데 실제로 데이터의 분포나 레코드의 건수에 따라서 순서는 달라질 수 있다
- 전문검색은 MATCH(), AGAINST() 구문을 사용해서 실행한다 이때 무조건 테이블에 전문 검색 인덱스가 준비돼어 있어야한다 
- 실제로는 range 접근 방법이 더 빨리 처리되는 경우가 많다고 한다
- 그래서 전문 검색 쿼리를 사용할때는 조건별로 성능을 확인해 보는 편이 좋다고 한다


**6. ref_or_null
- ref에 NULL 비교가 추가된 형태

select * from titles
where to_date ='1999-08-08' or to_date is null;



**7. index_merge**

- 2개 이상의 인덱스를 이용해서 각각의 검색결과를 만들어내고 그결과를 병합해서 처리하는 방식

특징
- 여러 인덱스를 읽어야해서 range 보다 효율성이 떨어짐
- 결과가 항상 2개 이상의 집합이 되어서 교집합, 합집합, 중복 제거 같은 부가적인 작업이 더 필요함

- MSQL 메뉴얼에서는 우선순위가 ref_or_null 바로 다음이지만 real mysql 책에서는 range 접근 방법 아래로 옮겼다 



**8. unique_subquery**
- where 절에서 IN  서브쿼리 형태의 쿼리에서 사용되는 방식이다
- 서브쿼리에서 중복되지 않는 유니크한 값만 반환할때 이 접근방법을 사용한다

select * from departments 
where dept_no in(select dept_no from dept_emp where emp_no = 10001);



**9. index_subquery
- unique_subquery 는 subquery가 중복된 값을 반환하지 않는데
- index_subquery는 subquery가 중복된 값을 반환할 수 있지만 index를 이용해서 중복된 값을 제거할 수 있을 때 사용됨 
- unique_subquery와 큰 차이는 없다



**10. range**
- 인덱스 레이지 스캔 형태의 접근 방법
- 인덱스를 하나의 값이 아니라 범위로 검색하는 경우
- <, >, Is null, between, in, like  연산을 이용할때
- 상당히 빠르고 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다


**11. index**
- 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미함
- 테이블 풀 스캔과 달리 테이블보다 크기가 작은 인덱스를 풀 스캔하므로 index 방식으로 처리가 가능하다면 테이블 풀 스캔보다 우선적으로 사용된다

- 다음 조건에 해당하면 사용됨
	- range/const/ref 등의 접근방식으로 인덱스 사용하지 못하는 경우 + 조회하는 칼럼이 모두 인덱스에 포함된 경우
	- range/const/ref 등의 접근방식으로 인덱스 사용하지 못하는 경우 + 인덱스를 통해 정렬/그룹핑이 가능한 경우



**12. ALL**
- 풀 테이블 스캔을 의미함
- 테이블을 처음부터 끝까지 읽어 조건에 해당하지 않는 데이터를 제거한다
- 가장 오래걸리는 방식으로, 빠른 응답이 필요한 조건에 대해서는 index 방식과 함께 피해야 하는 접근 방식이다



---

정리를 하자면

- type 컬럼은 MySQL 서버가 테이블의 레코드를 어떤 방식을 사용해 읽어왔는지를 의미한다.
- index, ALL 방식은 성능이 많이 느리므로, type에 index, ALL 방식으로 되어있다면 쿼리 튜닝을 고려해보도록 하자.
