## 아이템 86 - Serializable을 구현할 때는 신중하라

**Serializable 구현의 영향**
- 그 클래스의 내부 구현이 공개 API의 일부가 되어버린다
- 직렬화 형태가 외부 계약으로 굳어져 버린다 그래서 나중에 내부 구조를 변경하기 어렵고 호환성 문제가 생긴다

<br/>

**문제점**
1. 릴리스마다 버전 호환성 유지가 필요하다
  - serialVersionUID를 수동으로 관리해야한다
  - 내부 구조를 바꾸면 직렬화된 데이터와 호환되지 않을 수 있다
  - Serializable을 구현하는 순간 클래스의 직렬화 형태도 API가 된다.
  - 그래서 한 번 배포된 클래스는 구조 변경이 불가능하다


2. 버그와 보안 구멍이 생길 위헙이 높아진다
  - 역직렬화 시 생성자를 우회해서 객체가 생성된 -> 불변식이 깨질수 있음
  - 공격자가 조작된 바이트 스트림을 보내면 예상치 못한 객체 상태가 만들어질 수 있다
  - readObject는 또 하나의 public 생성자나 다름없다 그래서 클래스 불변식을 반드시 다시 검증해야 한다


3. 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다
  - Serializable을 구현한 클래스는 이전 버전과의 직렬화 호환성을 항상 유지해야 하기 때문이다
  - 그래서 구현해다면 그 이후 버전에서 클래스 구조를 바꿀때마다 아래를 전부 확인해야 한다
    1. 이전 버전으로 직렬화된 데이터가 새 버전에서 역직렬화될수 있는가
    2. 새 버전에서 직렬화한 데이터가 이전 버전에서도 읽을수 있는가
    3. 새 필드 추가, 필드 타입 변경, 삭제가 호환성에 영향을 주지 않는가
    4. serialVersionUID가 유지 되고 있는가
  - 다시 말해 매번 버전 간호환 테스트를 수행해야 한다

4. 캡슐화가 깨진다
  - 직렬화는 private 필드까지 저장한다
  - 클래스 내부 구현이 외부로 노출된다
  - 직렬화는 객체의 내부 표현을 외부로 드러내어서 캡슐화의 근본적인 이점을 해친다


<br/>

**상속용으로 설계된 클래스 는 대부분 구현하면 안되며 인터페이스도 대부분 Serializable을 확장해서는 안된다**
- 하위 클래스의 자유도를 빼앗기 때문이다
- 상속을 염두에 둔 클래스는 보통 하위 클래스가 새로운 필드를 추가하거나 상태를 확장하도록 설계되는데
- 상위클래스가 이미 구현하면 하위 클래스도 직렬화 체계를 따라야만 해서 하위 클래스의 설계 자유도가 크게 줄어든다


<br/>

**여러분이 작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의할 점이 몇가지 있다**
- 상위 클래스와 하위 클래스의 직렬화 체계를 모두 고려해야 한다
- 직렬화 가능 클래스는 직렬화 불가능한 상위 클래스으 상태도 복원할 수 있도록 해야 한다
- 상위 클래스가 Serializable이면 하위 클래스도 자동으로 된다
- 인스턴스 필드 값 중 불변식을 보장해야 할게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야한다
- 인스턴스 필드중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스ㅇ에 readObjectNoData 메서드를 반드시 추가해야 한다



<br/>

**여러분이 작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의할 점이 몇가지 있다**
- 상속용 클래스인데 직렬화를 지원하지 않으면 하위 클래스에서 직렬화를 지원하려 할때 부담이 늘어난다
- 역직렬화하려면 그 상위 클래스는 매개변수가 없는 생성자를 제공해야 하는데 여러분이 이런 생성자를 제공하지 않으면
- 하위 클래스에서는 어쩔수 없이 직려로하 프록시 패턴을 사용해야 한다


**내부 클래스는 직렬화를 구현하지 말아야 한다**
- 내부 클래스에 대한 기본 직렬화 형태는 분명하지 않다
- 단 정적 멤버 클래스는 Serializable 을 구현해도 된다

<br/>

**나의 정리**
- 한번 구현하면 영원히 호환성을 책임 져야해서 신중히 결정해야 한다
- 상속용 클래스, 내부 클래스는 절대 구현하지 말자
- 필요하다면 정적 멤버 클래스로 대체하자
