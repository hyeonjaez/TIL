## 아이템 87 - 커스텀 직렬화 형태를 고려하라

**기본 직렬화 형태**
- 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야한다
- 직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다고 한다

<br/>

**물리적 표현 vs 논리적 표현**
- 물리적 표현 : 클래스 내부의 필드와 자료구조 등 구현 방삭
- 논리적 표현 : 객체가 표현하는 의미 있는 상태
- 기본 직렬화는 물리적 표현을 그대로 저장하기 때문에 클래스 설계와 진화에 발목을 잡는다

<br/>

**객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네가지 문제가 생김**
1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다
  - 기존에 사용하던 자료구조를 더는 사용하지 않더라도 관련 코드를 절대 제거할 수 없다

2. 너무 많은 공간을 차지할 수 있다

3. 시간이 너무 많이 걸릴수있다

4. 스택 오버플로를 일으킬 수 있다

<br/>

**커스텀 직렬화 설계 방법**
1. transient 키워드 활용
  - 논리적 표현에 불필요한 필드를 직렬화 대상에서 제외한다

2. writeObject/readObject 메서드 구현
  - 객체의 논리적 상태만을 직렬화하고 복원하도록 제어할 수 있다

3. 역직렬화 시 불변식 검증
  - 생성자를 거치지 않아서 readObject 안에서 유효성 검사를 해야한다

4. readResolve/writeReplace 활용
  - 필요할 경우 역직렬화된 객체를 교체할 수 있다.

<br/>

**나의 정리**
- 기본 직렬화는 물리적 표현을 그대로 노출하기 때문에 캡슐화, 성능, 보안, 유지보수성에서 문제가 있다
- 그래서 논리적 표현만 직렬화하도록 커스텀 직렬화를 설계해야 한다















