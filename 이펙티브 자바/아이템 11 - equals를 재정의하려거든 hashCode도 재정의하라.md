## 아이템 11 - equals를 재정의하려거든 hashCode도 재정의하라
- equals()를 재정의 했다면 반드시 hashCode()도 재정의해야 한다
- 만약 재정의 하지 안흥면 equals()로는 같다고 판단되더라도 HashMap, HashSet 같은 해시 기반 컬렉션에서 올바르게 동작하지 않는다

<br/>

**hashCode 규약**
1. 일관성
  - 프로그램 실행 중 객체의 상태가 바뀌지 않았다면 여러 번 호출해도 항상 같은 값을 반환해야 한다

2. equals와의 일관성
  - a.equals(b)가 true 면 반드시 a.hashCode() == b.hashCode() 여야 한다

3. equals가 false인 경우
  - a.equals(b) 가 false일때 a.hashCode() 와 b.hashCode()는 달라도 되고 같아도 된다
  - 하지만 해시 충돌을 줄이기 위해 다른 값을 반환하게 해야한다

<br/>

**만약 해당 클래스의 모든 인스턴스의 hashCode가 같다면**
- 모든 객체가 해시테이블의 버킷 하나에 담겨서 연결리스트 처럼 동작하게 된다
- 그래서 성능이 O(1)인 해시 테이블이 O(n)으로 느려져서 객체가 많아지면 사용하면 안된다

<br/>

**hashCode를 재정의하지 않았을때**
- HashSet 컬렉션을 사용할때 내부적으로 hashCode 비교 -> 버킷 탐색 -> equals() 검사 이렇게 동작하는데
- hashCode가 재정의되지 않으면 같은 객체라도 다른 값으로 계산되어 버린다

<br/>

**올바른 구현 방법**
- equals()에 사용된 핵심필드들을 이용해서 hashCode()를 만드는 방법이다
- 해시 충돌을 줄이려면 서로 다른 필드의 해시 값을 곱셈 덧셈 조합으로 만든다
- Objects.hash()는 간단하지만 성능이 살짝 떨어질수도 있다 그래서 성능이 민감한 곳에서는 직접 구현하는 것을 권장한다

<br/>

**equals & hashCode**
- equals()를 재정의하면 반드시 hashCode()도 재정의 해야한다
- hashCode()만 재정의하는 경우는 없다
- 컬렉션에서 잘 동작하기 위해서는 둘은 항상 일관성을 유지해야 한다
