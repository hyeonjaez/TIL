## 아이템 13 - clone 재정의는 주의해서 진행해라

- clone()은 객체 복제를 제공한다
- 하지만 설계가 불완전하고 사용하기가 까다롭다는 단점이 있다
- 잘못 구현하면 얕은 복사로 인해 문제가 발생한핟
- 가능하다면 복사 생성자나 정적 팩터리 메서드를 사용하는 것이 더 안전하다


<br/>

**Clone 메서드 문제점**
1. 얕은 복사
  - super.clone()은 객체의 필드만 그대로 복사해서 참조 타입 필드는 같은 객체를 공유하게 된다
2. 생성자 호출 우회
  - clone()은 생성자를 거치지 않기 때문에 불변식이 깨질 위험이 있다
3. Checked Exception
  - CloneNotSupportedException이라는 예외처리가 필요하다

<br/>

**clone 구현 방법**
1. Cloneable 인터페이스 구현
2. super.clone() 호출
3. 가변 객체를 깊은 복사
  - 배열이나 컬렉션 같은 참조 필드는 새로 복사해야한다

<br/>

**복사 생성자와 정적 팩터리 메서드**
- clone 보다 단순하고 안전하다

- 장점
  - 예외 처리 불필요
  - 가독성 좋음
  - 상속 구조에서도 안전
 
<br/>

**얕은 복사와 깊은 복사**

얕은 복사
  - 객체의 1차 필드 값만 복사하는 것이다
  - 원시 타입은 값 자체가 복사되지만
  - 참조 타입은 참조 값 주소만 복사가 된다
  - 그래서 원본과 복제본이 같은 객체를 가리키게 된다

깊은 복사

  - 객체 내부의 참조 타입까지 새롭게 생성해서 완전히 독립적인 객체를 만드는 것이다
  - 원본과 복제본이 서로 간섭하지 않는다
  - 

<br/>

**clone()에서 불변식이 깨지는 이유**
불변식
- 클래스가 항상 만족해야 하는 객체의 내부 규칙, 제약조건이다

불변식이 깨지는 이유
1. 생성자를 거치지 않음
  - 일반적인 객체 생성 : new -> 생성자 호출 -> 초기화, 검증 로직 실행 -> 불변식 보장
  - clone() :  super.clone()이 메모리 단순 복제만 하고 생성자 로직을 건너뛰게 된다 그래서 검증/ 초기화 로직이 실행되지 않는다
3. 얕은 복사로 인한 공유 문제
