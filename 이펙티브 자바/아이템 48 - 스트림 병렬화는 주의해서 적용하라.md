## 아이템 48 - 스트림 병렬화는 주의해서 적용하라
- 스트림을 .parallel()로 병렬 실행할수 있다 하지만 무조건 성능이 좋아지는 건 아니다.


**병렬 스트림 특징**

1. ForkJoinPool
  - 병렬 스트림은 내부족으로 ForkJoinPool.commonPool()를 사용해서 작업을 분할하고 병렬 실행한다
  - CPU 코어 개수에 따라서 자동 병렬화
2. 효율적 병렬화 조건
  - 데이터가 클때
  - 분할이 효율적으로 가능할때
  - 연산 비용이 클때
  - 순차적 의존성이 없는 경우

<br/>

**병렬 스트림의 위험성**
1. 성능 저하
  - 데이터가 작거나 연산 비용이 낮으면 병렬화 오버헤드 때문에 오히려 느려짐
2. 잘못된 결과
  - 만약 부작용이 있으면 병렬 실행 시 레이스 컨디션으로 잘못된 결과를 만든다
3. 순서 의존 연산의 비효율
  - 순서 의존적 연산은 병렬화 시 큰 성능 손해가 난다

<br/>

**병렬화에 적합한 경우**
- 연산 비용이 큰경우
- 순서 의존성이 없는 경우
- 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위 일때
  - 왜냐하면 이 자료구조들은 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기 좋다는 특징이 이있다.
  - 참조 지역성이 좋기 때문이다

<br/>

**스트림 병렬화와 참조 지역성**
1. 좋은 데이터 소스 (Array, ArrayList 범위 기반 스트림)
   - 내부 데이터가 연속된 메모리에 저장됨
   - 불할시 일정한 범위로 나누기 쉽고 각 스레드가 연속된 구간을 처리 -> CPU 캐시 적중률 좋음
   - 공간 지역성이 뛰어나서 병렬 처리에 유리하다
  
2. 나쁜 데이터 소스 (LinkedList, Stream.iterate)
  - 원소가 메모리에 흩어져 있어 다음 노드를 따라가야한다
  - 캐시미스가 잦고 분할도 어렵다
  - 병렬화 효과가 거의 없거나 오히려 성능 악화

<br/>

**가이드라인**
1. 데이터 소스의 분할 성능을 따져라
2. 연산 비용이 충분히 크고 데이터 크기도 커야한다
3. 순서에 의존하지 않는 파이프라인을 병렬화하라
4. 반드시 성능 측정으로 검증하라 - 병렬화가 실제로 이득이 되는지는 측정하기 전엔 알수 없다

<br/>

