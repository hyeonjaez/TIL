## 아이템 29 - 이왕이면 제네릭 타입으로 만들라
- 제네릭이 없던 시절에는 컬렉션을 만들때 Object 기반으로 만들었다
- 이런 경우에는 꺼낼때마다 형변환이 필요했고 잘못된 타입을 꺼내게 되면 런타임 오류가 발생했다

```java
// 제네릭 없는 스택
public class Stack {
    private Object[] elements;
    private int size = 0;

    public void push(Object e) { elements[size++] = e; }
    public Object pop() { return elements[--size]; }
}

// 사용
Stack stack = new Stack();
stack.push("hello");
Integer i = (Integer) stack.pop(); // 런타임 오류
```

<br/>

**제네릭 타입으로 개선**
```java
// 제네릭 스택
public class Stack<E> {
    private E[] elements;
    private int size = 0;

    @SuppressWarnings("unchecked") // 내부에서만 경고 억제
    public Stack(int capacity) {
        elements = (E[]) new Object[capacity]; 
    }

    public void push(E e) { elements[size++] = e; }
    public E pop() { return elements[--size]; }
}

// 사용
Stack<String> stack = new Stack<>(10);
stack.push("hello");
String s = stack.pop(); // 형변환 불필요, 타입 안전
```

<br/>

**장점**
- 1. 타입 안정성 : 잘못된 타입을 넣거나 꺼내려 하면 컴파일러가 잡아줌
  2. 가독성 : 형변환 코드 제거 -> 더 명확한 코드
  3. 재사용성 : 한 번 구현하면 어떤 타입에도 활용 가능하다
 
<br/>


**배열을 사용한 코드를 제네릭으로 만드는 방법 2가지**
1. E[] 필드로 두고 생성 시에 한번만 캐스팅
- 장점 : 캐스트 경고가 생성자 한곳에만 있다 -> 가장 좁은 범위
- elements에는 오직 E만 넣는다는 클래스 내부 조건을 지켜야 안전하다

2. 내부는 Object[]로 들고 꺼낼때 캐스팅
- 장점 : 배열 생성 시 비검사 경고가 없다
- 단점 : 읽을 때마다 캐스팅이 필요하다

**어느쪽이 더 좋을까?**
- 둘다 안전하다 핵심은 배열에 E 아닌 걸 절대 넣지 않는다는 클래스 불변식을 지키는 것이다


<br/>

**나의 정리**
- 직접 형변환해야 하는 타입보다는 제네릭 타입이 더 안전하고 쓰기 편하다
- 새로운 타입을 설계할때는 형변환 없이도 사용할수 있도록 하자 이렇게 하려고 하면 제네릭 타입으로 만들어야 한다



