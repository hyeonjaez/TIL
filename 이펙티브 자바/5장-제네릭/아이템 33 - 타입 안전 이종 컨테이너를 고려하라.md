## 아이템 33 - 타입 안전 이종 컨테이너를 고려하라

**제네릭의 한계**
- 일반적인 제네릭 컨테이너는 하나의 타입 매개변수만 가진다

```java
class Favorites<T> {
}
```

- 여기에서 Favorties<String> 과 Favorties<Integer> 는 각각 문자열만, 정수만 저장할수 있다
- 다시 말해서 한 컨테이너가 여러 타입을 동시에 안전하게 다루기는 어렵다


**이종 타입 저장**
```java
Map<String, Object> map = new HashMap<>();
map.put("name", "JaeHyeon");
map.put("age", 27);

String name = (String) map.get("name"); // 형변환 필요
Integer age = (Integer) map.get("age");
```

- 위의 코드 처럼 하나의 객체에 String, Integer 등 여러 타입을 넣고 싶다면 이렇게 할수 있지만 여러 문제점이 있다
- 타입 안정성이 없다
- 런타임에 ClassCastException  발생 가능하다
- 컴파일러가 타입 오류를 잡아주지 못한다

<br/>

**해결책 : 타입 안전 이종 컨테이너**
- 책의 저자는 이 문제를 해결하기 위해 Key 자체에 타입 정보를 포함시키는 방식을 제안한다
- 키마다 다른 타입의 값을 안전하게 담을 수 있는 컨테이너이다

```java
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(type, instance);
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}
```

- 위 코드가 타입 안전 이종 컨테이너 패턴이다
- 키가 와일드 카드 타입으로 모든 키가 서로 다른 매개변수화 타입일 수 있다
- value는 Object인데 이 맵은 키와 값 사이의 타입 관계를 보증하지 않는다는 말이다 모든 값이 키로 명시한 타입임을 보증하지 않는다



**putFavorite()**
- Class 객체와 인스턴스를 favorites 에 추가해서 관계를 지으면 된다

**getFavorite()**
- 주어진 Class 객체에 해당하는 값을 favorites 맵에서 꺼낸다
- 이 객체가 바로 반환해야 할 객체가 맞미나 잘못된 컴파일 타입을 가지고 있다
-  이 객체의 타입은 Object여서 이것을 T로 바꿔 반환해야 한다
-  그래서 cast 메서드를 사용해서 이 객체 참조를 Class 객체가 가리키는 타입으로 동적 형변환한다
-  이 메서드는 Class 객체가 알려주는 타입의 인스턴스인지를 검사한 다음에 맞다면 그 인수를 그대로 반환하고 아니면 ClassCastException을 던진다
-  favorites 맵안의 값은 해당 키의 타입과 항상 일치함을 알고 있다


**Favorties의 제약 두가지**
1. Class 객체를 raw type 으로 넘기면 Favorites 인스턴스의 타입 안전성이 깨진다
```java
Favorites f = new Favorites();
f.putFavorite((Class) String.class, 123); // 컴파일러 경고 없음
String s = f.getFavorite(String.class);   // ClassCastException 발생
```
- (Class)는 raw type 으로 Class<?> 정보가 사라진다
- 그래서 컴파일러가 String.class 와 Integer의 불일치를 감지하지 못한다
- 런타임에서 ClassCastException이 발생한다
- 그래서 Class 객체는 반드시 Class<T> 형태로 넘겨야한다

<br/>

2. 실체화 불가 타입을 키로 사용할 수 없다
- List<String>, List<Integer> 같은 제네릭 타입은 런타임에 타입 정보가 지워져서 Class<T> 키로 사용할수 없다
- 제네릭 타입은 소거 되어 런타임에는 단순히 List로만 존재하고 그래서 List<String>과 List<Integer>는 구분이 불가능하다
- 결국에는 Class<T>키로는 사용하룻 없다

<br/>

**Favorites 가 사용하는 타입 토큰은 비한정적이다**
- 타입 토큰: 런타임에 제네릭 타입 정보를 전달하기 위한 객체
- 타입 토큰은 컴파일 시 타입 정보를 가지고 있다가 런타임에도 T의 타입을 안전하게 사용하게 해주는 역할이다.

Favorites 가 사용하는 타입 토큰
- Class<T>는 비한정적 타입 토큰이다 T에 대한 아무 제약이 없다
- 그래서 이 덕분에 하나의 컨테이너에 다양한 타입의 객체를 타입 안전하게 저장할 수 있다

<br/>

**애너테이션 API는 한정적 타입 토큰을 적극적으로 사용한다**
- 자바의 AnnotatedElement 인터페이스

```java
public interface AnnotatedElement {
    <T extends Annotation> T getAnnotation(Class<T> annotationClass);
}
```

- 타입을 보면 한정적 타입 토큰이다

- 그 이유는
- 애너테이션 API에서는 Annotation의 하위 타입만 전달 받아야 안전하기 때문이다
- 애너테이션 내에서 타입 안정성을 확보하기 위해


<br/>

**Favorites vs 애너테이션 API**
- 의도는
- Favorites : 비한정적이고 의도는 범용적으로 쓰기 위해
- 애너테이션 API : 한정적 이고 의도는 특정 계층 내에서 타입 안전성을 보장하기 위해


<br/>

**타입 안전 이종 컨테이너 이름 의미**
- Type-safe : 컴파일 타임에 타임 검증이 이루어짐
- Heterogeneous : 서로 다른 타입의 객체를 저장
- Container : 데이터를 보관하고 꺼내는 구조

<br/>

**나의 정리**

- 제네릭 컨테이너는 하나의 타입만 다룰 수 있어 여러 타입을 함께 안전하게 저장하기 어렵다
- 그래서 타입 안전 이종 컨테이너라는게 있는게 키에 타입 정보를 담아서 키마다 다른 타입의 값을 안전하게 저장할수 있는 구조이다

<br/>

- Class<T> 타입 토큰을 활용해 컴파일 타임 타입 안전성을 보장한다

<br/>

- 비한정적 타입 토큰을 사용하여 어떤 타입이든 저장할수 있지만
- raw type을 사용하면 타입 안전성이 깨지고 실체화 불가 타입은 컴파일 시점에 타입이 사라져서 사용할수 없다.

<br/>

- 애너테이션 API는 한정적 타입 토큰을 사용해 Annotation 하위 타입 내에서만 타입 안전성을 보장한다 



