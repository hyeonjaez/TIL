## 아이템 50 - 적시에 방어적 복사본을 만들라


- 클래스가 불변식을 보장하려면 외부에서 가져온 가변 객체를 그대로 저장하거나 반환하면 안된다.
- 필요한 경우 반드시 방어적 복사를 만들어 사용해야 한다.

**왜 필요한가?**
- 외부에서 전달된 가변 객체가 나중에 변경된다고 하면 내부 상태까지 변경될수도 있다.
- 클래스의 불변식이 위반되고 예상치 못한 버그가 발생한다
- 객체가 잠재적으로 변경될 수 있는지를 생각해야 하고 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제 없이 동작할지를 따져보고 확신할 수 없다면 복사본을 만들어 저장해야 한다

```java
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.after(end))
            throw new IllegalArgumentException(start + " after " + end);
        this.start = start;  // 그대로 참조 저장
        this.end = end;      // 대로 참조 저장
    }

    public Date start() { return start; } // 내부 가변 객체를 그대로 반환
    public Date end() { return end; }
}


Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78);  // 외부에서 end 수정 → Period 내부 상태도 깨짐
```



**방어적 복사 적용**
1. 생성자에서 복사하기 (입력값 방어)
```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    if (this.start.after(this.end)) {
        throw new IllegalArgumentException(start + " after " + end);
    }
}
```

2. 접근자에서 복사하기 (출력값 방어)
```java
public Date start() {
    return new Date(start.getTime()); // 방어적 복사
}

public Date end() {
    return new Date(end.getTime());   // 방어적 복사
}
```


<br/>

**주의할 점**
- clone() 사용 지양 : 생성자나 정적 팩토리 메서드를 통해서 복사가 더 안전하고 명확하다
- 방어적 복사의 비용 : 객체 복사 비용이 크면 성능 문제가 생길수 있다
- 방어적 복사를 피할수 있는 좋은 방법 : 불변 객체를 배개변수나 반환타입으로 사용한다 그럼 복사할 필요가 없다

**나의 정리**
- 외부에서 전달된 가변 객체를 그대로 저장하거나 반환하면 위험하고 생성자에서는 매개변수를 방어적으로 복사해 저장하고
- 접근자에서는 내부 상태를 방어적으로 복사해 반환해야 한다
- 불변객체를 활용하면 방어적 복사 자체를 피할수 있다.


