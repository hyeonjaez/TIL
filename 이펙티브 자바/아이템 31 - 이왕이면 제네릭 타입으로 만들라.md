## 아이템 31 - 이왕이면 제네릭 타입으로 만들라


- 제네릭 메서드나 클래스 설계 할때 타입 파라미터를 너무 빡빡하게 쓰면 호출 측에서 불편해진다
- 와일드 카드 와 한정을 적절히 써야 타입 안정성과 유연성을 동시에 확보할수 있다

**원칙**
PESC : Producer-Extends, Consumer-Super

- 값을 꺼내기만 할땐 ? extends T
- 값을 넣기만 할땐 ? super T

<br/>

**예시 1 : 유연하지 않은 API**
```java
// 두 집합을 합치는 메서드
public static <E> void union(Set<E> s1, Set<E> s2, Set<E> out) {
    out.addAll(s1);
    out.addAll(s2);
}
```

호출할때

```java
Set<Integer> ints = Set.of(1,2,3);
Set<Double> doubles = Set.of(3.0, 4.0);
Set<Number> numbers = new HashSet<>();
// union(ints, doubles, numbers); // 컴파일 에러
```
- 위 코드 처럼 타입이 달라지면 쓸수가 없다.

<br/>

**예시 2 : 한정적 와일드 카드 적용**
```java
public static <E> void union(
        Set<? extends E> s1,
        Set<? extends E> s2,
        Set<E> out) {
    out.addAll(s1);
    out.addAll(s2);
}
```

호출 할때
```java
union(ints, doubles, numbers); // 잘 동작
```

- ? extends E 로 정의해서 E의 하위 타입 집합들도 받아들일 수 있게 만들었다.


<br/>

**예시 3 : Stack API**

```java
class Stack<E> {
    // pushAll()
    public void pushAll(Iterable<E> src) { 
        for (E e : src) push(e);
    }
    // 개선
    public void pushAll(Iterable<? extends E> src) { // Producer → extends
        for (E e : src) push(e);
    }

    // popAll()
    public void popAll(Collection<E> dst) { // ❌ 유연하지 않음
        while (!isEmpty()) dst.add(pop());
    }
    // 개선
    public void popAll(Collection<? super E> dst) { // Consumer → super
        while (!isEmpty()) dst.add(pop());
    }
}
```

<br/>

**주의할 점**
- 와일드 카드를 과하게 사용하면 API 선언이 복잡해 진다
- 유연성이 필요한 매개변수에만 적용하고 반환 타입에는 쓰지 않는 것이 원칙이다


<br/>


**나의 정리**
- API 매개변수에는 extends와 super 와일드 카드를 적절하게 사용해서 호출 유연성을 높이고 PECS 원칙을 지키자





