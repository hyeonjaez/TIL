## 아이템 46 - 스트림에서는 부작용 없는 함수를 사용하라
- 스트림 파이프라인은 데이터를 함수형 스타일로 선언적으로 변환하는 도구이다.
- 중간 연산, 최종 연산에서는 부작용이 없어야 한다.
- 외부 상태를 변경하는 식은 피하고 Collectors 같은 종단 연산을 이용해야 한다.

**스트림 파이프라인 프로그래밍의 핵심**
- 부작용 없는 함수 객체를 사용하는 것
- 함수 객체 : 스트림의 각 단계는 보통 람다나 메서드 참조로 전달된 함수 객체로 동작한다 (데이터 -> 함수 객체 -> 변환 -> 최종결과)
- 부작용 없는 함수 객체 : 입력 -> 출력만 있을 뿐 외부 상태는 절대 바꾸지 않는 함수
- 왜?
  - 스트림은 병렬로 실행해서 부작용이 있으면 race condition발생
  - 스트림은 데이터를 무엇을 할지 선언적으로 표현하는 도구이지 어떻게 할지 제어하는 도구가 아니다
  - 외부 상태에 의존하지 않아서 결과가 항상 동일하다

<br/>


**잘못된 사용**
```java
Map<String, Long> freq = new HashMap<>();
words.stream()
     .forEach(word -> freq.merge(word, 1L, Long::sum)); // 부작용
```

- forEach 에서 외부상태를 변경하고 있다
- 동시성 문제와 버그 발생 위험이 크고 스트림을 함수형으로 쓴 의미가 줄어든다.


**forEach연산의 한계**
- 최종 연산이지만 데이터 가공하거나 수집하는 용도가 아니다.
- 용도 : 단순 출력, 로깅 같은 부작용 없는 
- forEach연산은 스트림 계산 결과를 보고할 때만 사용하고 계산하는데는 쓰지 말자

**수집기(collector)**
- 스트림 결과를 안전하게 선언적으로 모을수 있는 도구
- 스트림의 요소들을 어떻게 축소할지 전략을 캡슐화한 블랙 박스 객체
- 데이터 집계, 변환, 그룹핑 방식을 정의 해둔 것
- 블랙 박스 객체 : 내부 구현은 감추고 입력과 출력만으로 동작을 이해할 수 있는 시스템
  - 사용자는 어떻게 동작하는지는 몰라도 무엇을 할수 있는지만 알면됨

<br/>

**나의 정리**
- 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체를 사용하는 것이다
- 외부 상태를 변경하면 병렬로 처리하는 스트림은 race condition 같은 문제를 일으키고 스트림의 함수형 프로그램 장점을 해친다
- forEach는 결과를 소비하는데만 사용하고 데이터 가공이나 수집은 Collector 같은 수집기를 활용해야한다
- 결국 스트림은 무엇을 할지를 선언적으로 표현하는 도구이지 어떻게 할지를 제어하는 도구가 아니다
