## 아이템 7 - 다 쓴 객체 참조를 해제하라

- 자바는 c와 c++과는 다르게 JVM에서 GC가 있어 메모리 누수를 걱정하지 않아도 된다고 생각을 한다
- 하지만 객체를 더 이상 사용하지 않으면서도 참조를 남겨두면 GC가 수거하지 못해서 메모리 누수가 발생한다

**예를들면**

```java
public class Stack {
    private Object[] elements;
    private int size = 0;

    public Stack(int capacity) {
        elements = new Object[capacity];
    }

    public void push(Object e) {
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) throw new EmptyStackException();
        return elements[--size];
    }
}
```
- Stack 구현에 있엉 pop() 메서드에서 스택에서 꺼낸 객체가 배열에 남아 있다고 하자
- 배열의 size 이후 구간은 사실상 없는거나 마찬가지이다
- 하지만 참조가 살아 있어서 GC 대상이 안된다

<br/>

**해결 방법**
- 참조 해제
- 필요 없어진 객체 참조를 null로 해제 하면된다 -> GC가 정상적으로 수거할 수 있다


**주의해야 할때**
1. 컬렉션
  - 사용하지 않은 객체를 담아두면 메모리 누수 위험 큼
2. 캐시
  - 한 번담은 객체를 계속 들고 있으면 GC 동작을 못함
3. 리스너 / 콜백
  - 이벤트 리스너나 콜백을 등록만 하고 해제하지 않으면 더 이상 쓰지 않는 객체가 계속 메모리에 남는다



**나의 정리**
- 자바는 GC가 있지만 사용하지 않는 객체 참조를 방치하면 메모리 누수가 생긴다
- 특히 컬렉션 캐시 리스너에서 자주 발생하는데
- 해결책은
  - 다 쓴 객체 참조를 명시적으로 null 처리
  - 캐시나 리스너에는 약한 참조 활용
 
**약한 참조**
- 보통 객체 참조는 강한 참조라고한다
- 약한 참조는 GC가 객체를 더 이상 강하게 참조하는 곳이 없으면 언제든지 수거할 수 있도록 허용하는 참조이다
- WeakHashMap 이 대표적인 예시이다

