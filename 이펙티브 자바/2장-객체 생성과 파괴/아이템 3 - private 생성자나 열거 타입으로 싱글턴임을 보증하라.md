## 아이템 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라

**싱글턴 패턴**
- 인스턴스를 오직 하나만 생성할수 있는 클래스

**싱글턴을 만드는 방식 3가지**
  - 2가지 모두 생성자는 private로 감추고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버를 하나 마련해 둔다

<br/>

**1. public static 멤버가 final 필드 인 방식**
- 하나뿐임을 보장됨
- 하지만 리플렉션으로 private 생성자를 호출할 수 있다
- 방어하려면 생성자를 두번째 객체가 생성되려할때 예외를 던지면됨
- 간결하다

<br/>

**2. 정적 팩터리 메서드를 public static 멤버로 제공**
- 정적 메서드를 통해서만 인스턴스를 얻을수 있어서 클래스가 인스턴스를 하나만 유지하도록 강제할수 있다
- getInstance() 안에서 객체를 생성하도록 구현하면 실제로 필요할때까지 인스턴스를 만들지 않을수 있다 -> 지연 초기화 
- API를 바꾸지 않고도 싱글턴이 아니게 변경할수 있다
- 제네릭 싱글턴 팩터리로 만들수 있음
- 이런 장점이 필요하지 않다면 1번째 필드 방식이 좋다

<br/>

**하지만 위 두개의 방식이 직렬화할때 문제가 발생**
- 직렬화하면 Serializable을 구현한다고 선언하는 것 만으로는 부족하다
- 왜냐하면 인스턴스를 역직렬화할때마다 새로운 인스턴스가 만들어지기 때문이다
- 그래서 싱글턴임을 보장해주는 readResolve 메서드를 추가한다

<br/>

**마지막 방식 - 열거 타입(Enum)**
- 더 간결하고 추가적인 로직 없이 직렬화 할수 있다
- 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽하게 막아준다
- 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다

<br/>

**열거 타입의 단점**
- 상속을 해야한다면 이 방법을 사용할수 없다
- 하지만 열거 타입이 다른 인터페이스를 구현하도록 선언할수는 있다



## **나의 정리**
- 책에서는 생성자를 private로 두고 나서 싱글턴임을 보증하라고 한다
- 그래서 3가지 방식을 소개했고
- 정적 팩터리 방식에서 필드 값에 인스턴스를 두고 정적 팩터리 메서드로 인스턴스를 반환하게 소개를 하였다
- 하지만 내 생각에는 필드값에 먼저 인스턴스를 두는게 아니라 메서드 호출할때 딱 한번 만들어지게 된다면 더 좋아 질것 같다 그래야 위에서 소개한 지연 초기화라는 효과가 발생할수 있을거라고 생각한다
- 열거 타입은 애 자체가 싱글턴이라 상속이 필요하지 않다면 열거타입으로 싱글턴임을 보증하는게 제일 확실할거라고 생각한다

