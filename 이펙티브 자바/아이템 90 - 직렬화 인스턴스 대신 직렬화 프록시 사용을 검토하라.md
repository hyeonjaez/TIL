## 아이템 90 - 직렬화 인스턴스 대신 직렬화 프록시 사용을 검토하라

- 직렬화 프록시 패턴은 직렬화/역직렬화 시 객체 대신 프록시 객체를 주고 받게 하여 생성자에서 보장하던 불변식을 유지하고
- 캡슐화 보안 호환성을 강화하는 것이다


**언제 쓰나?**
- 불변식이 중요한 값 객체
- 내부 구현과 외부 의미가 다른 경우
- 향후 필드 구조가 바뀔 가능성이 있는 클래스

<br/>

**구조**

```java
public final class Period implements Serializable {
    private final LocalDate start;
    private final LocalDate end;

    public Period(LocalDate start, LocalDate end) {
        if (start == null || end == null || !start.isBefore(end))
            throw new IllegalArgumentException("유효하지 않은 기간");
        this.start = start;
        this.end = end;
    }

    // 1) 프록시 타입 정의: 논리 상태만 담는다
    private static class SerializationProxy implements Serializable {
        private static final long serialVersionUID = 1L;
        private final LocalDate start;
        private final LocalDate end;

        SerializationProxy(Period p) {
            this.start = p.start;
            this.end   = p.end;
        }

        // 4) 역직렬화 시, 반드시 '진짜' 생성자를 통해 원객체 복원 → 불변식 재검증
        private Object readResolve() {
            return new Period(start, end);
        }
    }

    // 2) 직렬화 단계에서 프록시로 교체
    private Object writeReplace() {
        return new SerializationProxy(this);
    }

    // 3) 우회 공격 차단: 프록시 없이 직접 읽기를 시도하면 실패
    private void readObject(ObjectInputStream s) throws InvalidObjectException {
        throw new InvalidObjectException("Serialization proxy required");
    }
}

```

1. 직렬화 : 실제 객체 -> writeReplace()가 호출되어서 프록시가 스트림으로 나간다
2. 역직렬화 : 스트림에서 프록시가 복원된다 -> 프록시의 readResolve()가 호출되어 원래 타입의 새 인스턴스를 생성자로 복구
3. 우회 차단 : 원 타입의 readObject는 아예 예외를 던져 프록시를 강제한다


<br/>

**장점**
- 불변식 보존 : 복원은 항상 생성자를 통하고 생성자 검증 로직이 그대로 적용된다
- 캡슐화 유지 : 프록시는 논리 상태만 담아 내부 구현을 숨김
- 역직렬화 공격을 readObject 차단
- 프록시 필드만 유지하면 내부 표현을 바꿔도 호환성을 지키기 쉽다

<br/>

**언제 다른 방법이 나을까**
- 단순한 값 클래스이고 물리/논리 표현 차이가 거의 없고 진화 가능성이 낮다면 : 커스텀 직렬화 만으로 충분할수 있다
- 싱글턴만 필요하고 상속이 필요 없다면 : enum 싱글턴이 가장 간단하고 안전하다







