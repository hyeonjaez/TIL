## 아이템 84 - 프로그램의 동작을 스레드 스케줄러에 기대지 말라

**스레드 스케줄러**
- 운영체제가 여러 스레드에 CPU 시간을 분배하는 시스템 컴포넌트
- CPU가 한번에 한 스레드만 실행할 수 있기 때문에
- 스케줄러가 어떤 스레드에 CPU를 얼마나 언제 줄지 결정한다

<br/>

**왜 스레드 스케줄러에 의존하면 안 되는가**
- 프로그램이 스레드 스케줄링에 의존하면 이식성이 떨어지고 실행 환경에 따라 성능이 급격히 달라질 수 있다
```java
while (!done)
    Thread.yield();
```

- CPU 양보를 통해 동작을 제어하는 프로그램은 어떤 시스템에서는 잘 작동하지만
- 다른 시스템에서는 무한 대기하거나 CPU를 100% 점유할 수도 있다.
- 따라서 스케줄러에 의존하는 로직은 결코 신뢰할 수 없다

**Thread.yield()**
- 현재 실행 중인 스레드가 잠깐 CPU 사용을 양보하겠다고 요청하는 메서드
- 나 지금 CPU를 사용하고 있는데 다른 스레드에게 먼저 기회를 줘도 된다 라고 스케줄러에게 힌트를 주는 역할

**이식성**
- 프로그램이 여러 환경에서 동일하게 동작할 수 있는 능력

<br/>

**동시성 유틸리티와 명시적 동기화 사용**
- 스레드 간의 협력은 절대 스케줄러에 맡긱지 말고 명시적인 동기화 synchronization 기법으로 제어하라

**공평성에 기대지 마라**
- 스케줄러의 또 다른 문제는 공평성이다
- 어떤 스레드가 오래 기다렸으니 CPU를 먼저 줘야 한다는 보장은 없다
- 스케줄러의 공평성에 기대지 말고 필요하면 명시적으로 락이나 조건을 설정하자

<br/>

**Thread.yield()는 사용하지 말라**
- 스케줄러가 CPU 시간을 양보하도록 요청 할 뿐 실제로 양보할지는 아무 보장도 없다
- yield()는 단지 힌트일 뿐이고 프로그램의 올바른 동작을 보장하지 못한다


<br/>

**sleep() 도 스케줄링 제어 수단이 아니다**
- 단지 이 스레드를 일정 시간 멈춰달라고 요청하는 것일 뿐이다
- 스케줄러는 다른 스레드가 언제 실행될지 얼마의 CPU를 쓸지 같은 결정할 권한을 가진다

<br/>


**스케줄러의 정책에 의존하지 말고 CPU 활용도를 높이는 코드 구조를 선택하자**
- ThreadPoolExecutor의 스레드 풀 크기를 조정해 병렬성 확보
- BlockingQueue로 CPU 낭비 없는 작업 대기
- 스레드 간 경쟁을 줄이는 락 최소화
- 시스템이 아니라 코드 레벨에서 제어하라는 뜻이다.


<br/>

**책에서 말하고자 하는 것**
- 프로그램의 동작을 스레드 스케줄러에 기대지 말자
- 동시성 유틸리티와 명시적 동기화를 통해서 실행 순서를 스스로 제어하자

<br/>

**나의 정리**
- 스레드 스케줄러는 제어 불가능한 요소여서 의존하지 말자
- 프로그램의 올바른 동작은 항상 동기화 매커니즘으로 보장해야 한다
- Thread.yield(), sleep() 스케줄러의 공평성에 기대면 안된다
- 명시적 동시성 도구를 사용하자 


