## 28 - 배열보다는 리스트를 사용하라

**배열과 리스트 차이**
1. 공변 vs 불공변
  - 배열은 공변
    ```java
    Object[] objs = new String[10]; //허용된다
    objs[0] = 123;  // 런타임에서 ArrayStoreException 발생한다
    ```

  - 제네릭은 불공변
    ```java
    List<Object> objs = new ArrayList<String>(); // 컴파일 오류 
    ```

- 다시 말해서 배열은 런타임에 오류를 리스트는 컴파일 타임에 오류를 잡아준다


2. 실체화 vs 타입 소거
  - 배열은 실체화 : 런타임에도 원소 타입을 알고 검사 가능
  - 제네릭은 타입 소거 : 컴파일 타임에만 타입 검사 런타임에는 타입 정보가 없다
  - 그래서 new List<String>[10] 같은 제네릭 배열 생성은 금지되어 있다 (타입안정성 때문에)


<br/>

**공변과 불공변**
- 공변 : 하위 타입 관계가 그대로 유지되는 것 (컴파일러는 허용하지만 런타임에 에러가 발생)
- 불공변 : 하위 타입 관계가 전달되지 않는 것 (컴파일러가 아예 차단해서 타입 안정성을 보장)

<br/>

**실체화, 소거**
- 실체화 : 타입 정보가 런타임까지 유지되는 것
- 소거 : 타입 정보가 컴파일 이후 사라지는 것
- 제네릭은 소거 :컴파일 타임에만 타입을 검사하고 런타임에는 타입 정보가 지워진다

<br/>

**왜 리스트를 권장할까**
1. 타입 안정성
  - 배열은 런타임 오류 발생
  - 리스트는 컴파일 시점에 오류를 잡는다
2. 일관성
3. 표현력

<br/>

**배열과 리스틀 섞어서 쓰지말자**
```java
List<String>[] stringLists = new List[1]; // (경고 억제로 생성했다고 가정)
Object[] objects = stringLists; 
objects[0] = List.of(123);  // 다른 타입 List 삽입

String s = stringLists[0].get(0); // 런타임 ClassCastException 
```
- 배열은 공변이라 Object[]로 대입이 가능하다
- 하지만 그 안에 List<Integer> 를 넣게 되면 컴파일러는 잡아내지 못하고 런타임에서 오류가 발생한다
- 제네릭의 타입 안정성이 완전히 깨져버린다


**나의 정리**
- 배열과은 공변이고 실체화, 제네릭은 불공변이고 타입 정보가 소거된다
- 배열은 런타임에는 타입 안전하지만 컴파일 타임에는 그렇지 않는다 제네릭은 반대다
- 그래서 둘을 섞어 쓰면 타입 안정성이 깨지고 런타임 오류가 발생해서 섞지 말고
- 가장 먼저 배열을 리스트로 대체하는 방법을 적용하자
