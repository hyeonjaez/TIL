## 아이템 78 - 공유 중인 가변 데이터는 동기화해 사용하라

- 동기화는 단지 원자성을 보장하기 위한 수단잉 아니다
- 스레드 간에 변경된 값을 보이게 하기 위한 수단이기도 하다


<br/>

**문제 예시**
```java
public class StopThread {
    private static boolean stopRequested;

    public static void main(String[] args) throws InterruptedException {
        Thread backgroundThread = new Thread(() -> {
            int i = 0;
            while (!stopRequested)
                i++;
        });

        backgroundThread.start();
        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
    }
}
```

- 이 예제가 무한 루프에 빠질수 있다
- 왜냐하면 backgroundThread가 stopRequested의 변경을 보지 못할수도 있기 때문
- 이는 가시성 문제 때문이다

<br/>

**해경방법 1 - synchronized 접근자 사용**
```java
private static boolean stopRequested;

private static synchronized void requestStop() {
    stopRequested = true;
}

private static synchronized boolean stopRequested() {
    return stopRequested;
}
```

- 하나의 스레드만 동시에 접근할수 있는 배타성
- 한 스레드의 변경을 다른 스레드가 확실히 볼 수 있는 가시성
- 위 두가지가 보장된다


<br/>

**해결방법 2 - volatile 사용**
```java
private static volatile boolean stopRequested;
```

- volatile 키워드는 변경 즉시 다른 스레드가 볼 수 있도록 보장한다
- 가시성은 보장하지만 원자적 연산은 보장하지 않는다.
- 변수의 갱신이 모든 스레드에 즉시 반영되도록 보장하지만 복합 연산에는 사용할 수 없다.

<br/>

**복합 연산은 동기화해야 한다**
```java
private static volatile int nextSerialNumber = 0;

public static int generateSerialNumber() {
    return nextSerialNumber++;
}
```

- 위 코드는 스레드 안전하지 않다
- 왜냐하면 ++ 연산이 단일 원자 연산이 아니라
- 읽기 -> 증가 -> 쓰기 세 단계로 이루어지기 때문이다.
- 이렇게 세단계를 거쳐서 여러 스레드가 동시에 실행하면 같은 값을 반환할 수 있다

- 해결책은
```java
private static int nextSerialNumber = 0;

public static synchronized int generateSerialNumber() {
    return nextSerialNumber++;
}
```
- 위 코드 처럼 해결하거나 AtomicInteger 를 사용할수도 있다

<br/>

**책에서 말하고자 하는것**
- 공유되는 가변 데이터는 반드시 동기화해야 한다
- 단순히 읽기 전용이라면 동기화할 필요 없다
- volatile은 가시성 보장, 원자성은 보장하지 않는다.
- 복합 상태 변경에는 synchronized, Lock, Atomic 변수를 사용하자

<br/>

**불변 객체로 해결하는 방법**
- 가능한 한 공유되는 객체는 불변으로 설계하라
- 내부 상태가 변하지 않아서 동기화 없이도 여러 스레드가 안전하게 공유할수 있다.


**원자성, 가시성**
- 원자성 : 실행도중에 중간 상태가 노출되지 않는것 
- 가시성 : 하나의 스레드가 변경한 값이 다른 스레드에게 언제, 어떻게 보이는가

