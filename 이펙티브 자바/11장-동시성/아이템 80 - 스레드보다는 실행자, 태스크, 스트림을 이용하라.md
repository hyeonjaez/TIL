## 아이템 80 - 스레드보다는 실행자, 태스크, 스트림을 이용하라


**직접 스레드를 사용하는 문제점**
```java
new Thread(() -> doWork()).start();
```

- 스레드 생성 비용 비싸고 너무 많이 만들면 시스템이 불안정해진다
- 스레드의 수명, 예외 처리, 종료 시점등을 직접 관리해야함
- CPU 수보다 많은 스레드를 만들면 오히려 느려진다
- 스레드 내부에서 던진 예외를 잡거나, 실행 결과를 수집하기 어렵다

- 다시 말해서 스레드를 직접 다루는 것은 로우 레벨이고 유지보수성이 낮다


<br/>

**해결책 : Executor Framework 사용**
- 자바 5부터 도입된 java.util.concurrent 패키지의 Executor 프레임워크는 스레드를 직접 관리하지 않고 task 단위로 실행할수 있게 해준다.
```java
ExecutorService executor = Executors.newFixedThreadPool(3);

executor.execute(() -> System.out.println("Task 1"));
executor.execute(() -> System.out.println("Task 2"));
executor.shutdown();
```

- ExecutorService가 스레드 풀을 대신 관리한다
- 우리는 작업단위만 전달하면된다
- 내부적으로 스레드를 재사용해서 효율적이다

<br/>

**Task?**
- 비동기적으로 실행할 수 있는 작업 단위

- Runnable -> 값을 반환하지 않음
- Callable<T> -> 값을 반환하고 예외를 던질수 있다


<br/>

**스레드 풀 종류 (Executors 팩토리 메서드)**
- newFixedThreadPool(n) : 고정된 개수의 스레드로 태스크 처리
- newCachedThreadPool() : 필요할때마다 스레드 생성
- newSingleThreadExecutor() : 단일 스레드에서 순차적으로 실행
- newScheduledThreadPool(n) : 일정 시간 간격으로 반복 실행 가능


<br/>

**Fork/Join 프레임워크 - 병렬 처리**
- 큰 작업을 작은 태스크로 분할(fork)하고 각 결과를 합치는 (join) 구조
- CPU 코어를 최대한 활용할 수 있다

<br/>

**Stream으로의 발전**
- 자바 8 이후에는 대부분의 병렬 처리나 태스크 실행을 Parallel Stream으로 대체할 수 있다
- 내부적으로 ForkJoinPool을 이용하여 병렬 실행하다
- 코드가 간결하고 스레드 관리가 필요 없다


<br/>

**책에서 말하고자 하는 것**
- 스레드를 직접 다루지 말고 실행자(Executor), Task, Stream 같은 고수준 추상화를 사용하자
- 이들은 더 안전하고 효율적이고 관리하기 쉽다

<br/>

**나의 정리**
- 스레드를 직접 만들면 관리, 확장성, 예외처리, 성능 모두 불리하다
- 대신 ExecutorService를 사용하면 태스크 단위로 작업을 위임할수 있다
- Runnable, Callable, Future 로 비동기 작업을 안전하게 처리할 수 있다
- 병렬 작업은 ForkJoinPool 이나 parallelStream으로 간결하게 수행하자

- 다시 말해서 스레드를 직접 제어하기 보다는 실행자, Task, Stream으로 추상화하자

