## 아이템 79 - 과도한 동기화는 피하라

**동기화**

**동기화가 가져오는 위험**
1. 교착 상태 (Deadlock)
  - 서로 다른 스레드가 서로의 락을 기다리며 무한 대기하는 상태

2. 활주 (Livelock)
  - 교착 상태처럼 진행이 멈추지는 않지만
  - 서로 양보하느라 실질적인 진전이 없는 상태
  - 쉽게 말해서 프로그램이 계속 움직이지만 일은 하지 않는 상태

3. 성능 저하
  - 불필요하게 넓은 범위를 동기화하면 스레드 간 경합이 증가하고 CPU 자원을 낭비하게 된다

<br/>

**공개 메서드 안에서 동기화하지 말라**
- 클라이언트가 제공한 함수를 동기화된 영역 안에서 호출하면 안된다.
- 교착 상태나 예기치 못한 동작을 유발할수 있다
- 동기화된 메서드 안에서 콜백이나 오버라이드 가능한 메서드를 호출하지 말라는 뜻이다.

<br/>

**예시**
```java
public class ObservableSet<E> extends ForwardingSet<E> {
    private final List<SetObserver<E>> observers = new ArrayList<>();

    public void addObserver(SetObserver<E> observer) {
        synchronized(observers) {
            observers.add(observer);
        }
    }

    public void notifyElementAdded(E element) {
        synchronized(observers) {
            for (SetObserver<E> observer : observers)
                observer.added(this, element); // 동기화된 블록 내부에서 외부 메서드 호출
        }
    }
}
```
- 위 코드는 교착 상태 위험이 있다.
- observer.added() 내부에서 다시 ObservableSet의 메서드를 호출하면 락을 중첩해서 얻으려다 데드락이 발생할수 있다


<br/>

**해결책 - 동기화 블록 밖에서 외부 메서드 호출하기**
```java
public void notifyElementAdded(E element) {
    List<SetObserver<E>> snapshot;
    synchronized(observers) {
        snapshot = new ArrayList<>(observers); // 복사본을 만들어
    }
    for (SetObserver<E> observer : snapshot)  // 락 밖에서 콜백 실행
        observer.added(this, element);
}
```

- 이렇게 하면 observer.added()가 락을 얻지 않고 실행되어서 교착 상태가 발생하지 않는다

- 동기화 블록 밖에서 클라이언트가 제공한 메서드를 호출하자
- 락을 오래 쥐고 잇지 말라

<br/>

**성능 고려**
- 동기화 비용이 비싸다
- 짧은 코드만 동기화하고 계산이나 I/O는 동기화 밖에서 수행하라
- 필요하지 않은 경우에는 java.util.concurrent 패키지의 병렬 컬렉션이나 Atomic 클래스를 사용하는 것이 더 효율적이다


<br/>

**책에서 말하고자 하는 것**
- 클라이언트가 제공한 함수나 외부 메서드를 동기화된 영역 안에서 호출하지 말라 그렇지 않으면 예측할 수 없는 교착 상태나 예외가 발생할수 있다
- 락을 오래 쥐고 있으면 응답성과 확장성이 나빠진다 최소한의 필요 영역만 동기화하라

<br/>


**나의 정리**
- 동기화는 안전성을 위해 필요하지만 남용하면 교착상태, 성능 저하를 일으킨다
- 동기화된 블록 안에서는 외부 메서드를 호출하지 말자
- 락을 오래 쥐지 말고 복사본을 만들어서 락 밖에서 작업하자
- 계산, 로깅, I/O는 동기화 영역 밖에서 수행하자
- 가능하면 java.util.concurrent 라이브러리를 사용하자
