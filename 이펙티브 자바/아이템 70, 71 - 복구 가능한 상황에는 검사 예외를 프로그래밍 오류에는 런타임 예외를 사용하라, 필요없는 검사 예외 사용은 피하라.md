## 아이템 70, 71 - 복구 가능한 상황에는 검사 예외를 프로그래밍 오류에는 런타임 예외를 사용하라, 필요없는 검사 예외 사용은 피하라

**예외 구분**
1. checked excetpion
  - 호출하는 쪽에서 반드시 처리해야 하는 예외
  - 복구 가능한 상황일때 사용
  - 호출자가 적절히 대응할 수 있는 경우

2. unchecked exception
  - RuntimeExcetpion의 하위 클래스
  - 프로그래밍 오류를 나타낸다
  - 복구할 수 없는 상황일 때 사용

3. Error
   - JVM 자원 부족등의 시스템 레벨 문제
   - 애프리케이션이 복구를 시도해서는 안됨

  <br/>
  
정리하자면 
- 복구 가능 -> checked exception
- 프로그래밍 오류 -> unchecked exception
- 시스템 레벨 문제 -> Error

<br/>

**나의 정리**
- 예외를 설계할 때는 복구 가능성이 기준이다
- 복구 할수 있다면 검사 예외
- 복구 불가능하고 프로그래밍 오류라면 런타임 예외
- 시스템 자원 고갈 등 치명적 문제라면 에러

<br/>

**필요 없는 검사 예외 사용은 피하자**

- 검사 예외는 때론 안정성있게 해주지만 불필요하게 사용하면 API 사용성을 해치게 된다
- 호출자가 예외를 처리할 방법이 없는데 검사 예외를 던지게 된다면 try-catch 블록만 늘어나게 된다.


**언제 검사 예외를 쓸까?**
- 호출자가 의미 있는 복구 작업을 할수 있는 경우에만
- ex) 사용자가 다른 파일을 선택하거나 재시도 가능할때


**대안**
1. 런타임 예외 사용
  - 복구 불가능하다면 런타임 예외로 전환
  - 불필요한 try-catch를 피할수 있다


2. Optional 변환
  - 값이 없을수도 있다는 의미만 전달하려는 경우에는 Optional<T> 사용하자

3. boolean 이나 특수 값 반환
  - 단순하게 성공, 실패 여부만 필요하다면 검사 예외 대신에 boolean 반환


**나의 정리**
- 검사 예외는 API를 안젇ㅇ성을 높여주지만 남용하면 쓰기 고통 스러운 API를 낳는다
- 호출자가 진짜로 복구할 수 있는 상황에서만 검사 예외를 던지고
- 그외에는 옵셔널 을 반환해도 될지 고민하자










