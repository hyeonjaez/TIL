## 아이템 73 - 추상화 수준에 맞는 예외를 던지라

- 하위 계층의 예외를 상위 계층에 그대로 노출하지 말자
- 상위 계층의 API는 자신의 추상화 수준에 맞는 예외로 변환해서 던져야 한다
- 내부구현에 종속된 예외가 외부로 새어 나가면 캡슐화가 깨진다

<br/>

**문제**

```java
class DataService {
    public void load() throws SQLException {  // DB 예외가 직접 노출됨
        // JDBC 코드
        throw new SQLException("DB connection failed");
    }
}

class UserService {
    private final DataService dataService = new DataService();
    
    public void getUserData() throws SQLException {  // 상위 계층까지 노출
        dataService.load();
    }
}
```

- 상위 계층은 데이터베이스를 직접 사용하지 않는데도 SQLException이라는 하위 기술 예외를 알아야한다
- 추상화가 깨지고 나중에 구현이 바뀐다면 API 전체를 수정해야 한다


<br/>

**문제 해결**
```java
class DataService {
    public void load() {
        try {
            // JDBC 코드
            throw new SQLException("DB connection failed");
        } catch (SQLException e) {
            throw new DataAccessException("데이터 로딩 실패", e); // 변환 후 던짐
        }
    }
}

class DataAccessException extends RuntimeException {
    public DataAccessException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

- SQLException을 의미적으로 더 상위 계층에 맞는 예외로 변환한다
- 외부에는 데이터 접근 실패 라는 추상적 의미만 전달
- 내부 구현을 바꿔도 상위 API에는 영향이 없다


<br/>


**예외 번역**
- 하위 계층 예외 -> 상위 계층의 의미에 맞는 예외로 변환해서 던지는 기법
- 예외를 감싸서 다시 던질때는 반드시 원인을 함께 넘겨야 한다


**예외 연쇄**
- 상위 예외를 던지되 내부 원인을 함께 보존하는 것
- Throwable 생성자의 두번때 인자로 cause 를 전달
- 예외를 숨기지 않고 디버깅 가능한 상태로 유지

<br/>

**나의 정리**
- 상위 계층에서는 하위 기술의 예외를 직접 노출하지 말고 해당 계층의 추상화 수준에 맞는 의미적 예외로 변환해야 한다
- 디버깅을 위해 원인 예외는 반드시 포함하자








