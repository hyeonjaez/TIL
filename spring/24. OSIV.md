## 24. OSIV

### 🧠 개념 설명
- Open Session In View 라고 하고 OSIV는 하이버네이트에서 사용하는 용어이고
- JPA에서는 OEIV(Open EntityManager In View) 라고 한다
- 영속성 컨텍스트를 뷰까지 열어둔다라는 뜻이다
- 영속성 컨텍스트가 살아 있다면 엔티티는 영속 상태를 유지하는데 OSIV로 뷰에서도 지연 로딩을 사용할 수 있다.



**1. 요청 당 트랜잭션 방식**
- 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날때 트랜잭션도 끝내는 것
- 이렇게 하면 영속성 컨텍스트가 처음부터 끝까지 살아 있어 조회한 엔티티도 영속 상태를 유지한다
- 그래서 뷰에서도 지연 로딩을 할 수 있어서 엔티티를 미리 초기화할 필요 없다

문제점
- 컨트롤러에서 사용자 화면에만 보여줄 의도로 엔티티를 수정했다고 한다면 영속 상태인 엔티티를 수정해서 영속성 컨텍스트의 변경 감지 기능이 작동해서 데이터베이스에 반영이 되어 버린다
- 서비스 계층처럼 비즈니스 로직을 실행하는 곳에서 데이터를 변경하는 것은 당연하다
- 하지만 프레젠테이션 계층에서 데이터를 잠시 변경했다고 실제 데이터베이스까지 변경 내용이 반영된다고 하면 유지보수가 힘들어진다

이 문제점의 해결방법
- 엔티티를 읽기 전용 인터페이스로 제공
- 엔티티 래핑
- DTO만 반환


**2. 비즈니스 계층 트랜잭션 방식**
- 기존에 요청당 트랜잭션 방식의 OSIV는 프리젠테이션 계층에서 데이터를 변경할 수 있다는 문제점을 해결한 방법이다
- 스프링 프레임워크가 제공하는 OSIV는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV이다
- OSIV는 사용하지만 트랜잭션은 비즈니스 계층에서만 사용한다는 뜻이다
- 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 생성하고 트랜잭션은 생성하지 않는다
- 서비스 계층에서 @Transactional로 트랜잭션을 시작할 때 미리 생성해두었던 영속성 컨텍스트를 찾아서 트랜잭션을 시작한다
- 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다
- 이때 트랜잭션은 끝나지만 영속성 컨텍스트는 종료하지 않는다
- 이렇게 됨으로써 컨트롤러와 뷰까지 영속성 컨텍스트가 유지가 되어서 조회한 엔티티는 영속 상태를 유지한다
- 영속성 컨텍스트는 서블릿 필터나 스프링 인터셉터에서 종료하는데 플러시를 호출하지 않고 종료한다

**정리하자면**
- 영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있음
- 범위 밖에서는 엔티티를 조회만 할 수 있다 -> 트랜잭션 없이 읽기
- 그래서 프리젝테이션 계층에서는 트랜잭션이 없지만 트랜잭션 없이 읽기를 사용해서 지연로딩을 할 수 있다

**주의 사항**
- 프리젠테이션 계층에서 영속화 된 엔티티를 수정한후에 트랜잭션을 시작하는 서비스 계층을 호출한다고 하면
- 트랜잭션이 시작하고 다시 메소드가 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시 해서 변경 감지가 동작하여 데이터베이스에 반영한다
- 이런 주의 사항 이 있다
- 만약 OSIV를 사용하지 않는 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다고 하면 이런 문제가 발생하지 않는다

<br/>


**OSIV의 장점**
- 지연 로딩 문제 해결 : 엔티티는 영속성 컨텍스트가 열려 있는 동안만 lazy loading을 수행할 수 있는데 컨트롤러나 뷰에서 접근하려고 하면 이미 영속성 컨텍스트가 닫혀 있어서 예외가 발생한다
- 복잡한 DTO의 설계 없이 엔티티로 바로 뷰에 필요한 데이터를 접근 가능하다
- 트랜잭션 외부에서도 읽기가 가능하다


**OSIV의 단점**
- 커넥션이 오랫동안 점유되어서 트래픽이 몰리면 데이터베이스 커넥션 고갈 위험이 있다
  - 하이버 네이트는 지연 로딩 때문에 필요할때마다 커넥션을 요구한다
  - 그래서 트래픽이 몰릴때 지연 로딩으로 인해서 컨트롤러 뷰 계층에서 커넥션을 잡고 안 놓는 일이 생길수도 있다


---
### ✅ 한줄로 설명 하기
- OSIV는 영속성 컨텍스트를 뷰까지 열어서 지연로딩을 허용한다 
